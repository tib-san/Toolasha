================================================================================
LISTING PRICE DISPLAY - COMPREHENSIVE FAILURE ANALYSIS
================================================================================

Issue: Custom columns (Top Order Price, Total Price, Listing Age) disappear
from My Listings tab when creating a new listing. Columns only return after
page refresh.

Date: January 14, 2025
File: src/features/market/listing-price-display.js

================================================================================
EXECUTION FLOW ANALYSIS
================================================================================

Normal Flow (Page Load - WORKS):
1. loadInitialListings() populates this.allListings from dataManager
2. DOM observer detects table appearance
3. updateTable() is called
4. React has fully rendered table at this point
5. rowCount matches listingCount check passes
6. Columns added successfully

Broken Flow (New Listing Created - FAILS):
1. User creates new listing
2. WebSocket event 'market_listings_updated' fires
3. handleListing() updates this.allListings (count increases)
4. clearDisplays() removes ALL columns and processed flags
5. Manual updateTable(visibleTable) is called IMMEDIATELY
6. React hasn't updated DOM yet - old row count
7. Check fails: rowCount (old) !== listingCount (new)
8. Function returns early - columns never re-added
9. User refreshes page - normal flow works

================================================================================
IDENTIFIED ISSUES
================================================================================

CRITICAL ISSUE #1: Race Condition Between WebSocket and React DOM Updates
------------------------------------------------------------------------
Location: lines 64-78 (updateHandler)

Problem:
- WebSocket event fires BEFORE React updates the DOM
- We update this.allListings immediately (listingCount increases)
- We call clearDisplays() immediately (removes columns)
- We call updateTable() immediately (tries to re-add columns)
- BUT: tbody.querySelectorAll('tr').length still has OLD row count
- Check fails: rowCount !== listingCount
- Function returns without adding columns

Evidence:
- Page refresh works (DOM fully rendered before updateTable)
- Immediate processing fails (DOM not ready)

Fix Strategy:
- Add delay/retry mechanism to wait for React
- Use MutationObserver to detect when React adds the row
- Implement requestAnimationFrame + polling approach

------------------------------------------------------------------------

CRITICAL ISSUE #2: Row Count Logic Too Strict
------------------------------------------------------------------------
Location: lines 153-158 (updateTable)

Problem:
if (rowCount !== listingCount) {
    return; // Table not fully populated yet
}

This check is EXACT equality. If called too early:
- rowCount = 3 (old count before React updates)
- listingCount = 4 (new count from WebSocket)
- Function exits without processing

Why This Exists:
- Prevents processing partial table during initial load
- Ensures ALL rows are present before matching listings

Why It Fails:
- Too strict for dynamic updates
- No retry mechanism
- Assumes table is always fully updated before call

Fix Strategy:
- Change to >= check (allow extra rows)
- Add retry mechanism with exponential backoff
- Remove check entirely and match available rows only

------------------------------------------------------------------------

CRITICAL ISSUE #3: clearDisplays() Too Aggressive
------------------------------------------------------------------------
Location: lines 476-482 (clearDisplays)

Problem:
document.querySelectorAll('.mwi-listing-prices-set').forEach(table => {
    table.classList.remove('mwi-listing-prices-set');
});
document.querySelectorAll('.mwi-listing-price-header').forEach(el => el.remove());
document.querySelectorAll('.mwi-listing-price-cell').forEach(el => el.remove());

This removes:
- ALL processed flags (not just the table being updated)
- ALL header cells (including from other tabs if open)
- ALL data cells (destructive removal)

Why This Exists:
- Ensures clean slate for re-rendering
- Prevents duplicate columns

Why It Fails:
- Removes elements that won't be re-added if updateTable() fails
- Global scope instead of table-specific
- No way to recover if subsequent updateTable() fails

Fix Strategy:
- Clear only the specific table being updated
- Keep destructive removal but ensure re-add is guaranteed
- Add error handling to restore columns if update fails

------------------------------------------------------------------------

ISSUE #4: No Retry or Delay Mechanism
------------------------------------------------------------------------
Location: lines 72-77 (manual re-processing attempt)

Problem:
const visibleTable = document.querySelector('[class*="MarketplacePanel_myListingsTable"]');
if (visibleTable) {
    this.updateTable(visibleTable);
}

Called ONCE, immediately after clearDisplays(). No:
- Delay to wait for React
- Retry if first attempt fails
- Mutation observer to detect DOM changes
- requestAnimationFrame to wait for next paint

Why This Fails:
- Single synchronous call
- No accommodation for React's async rendering
- No fallback if table not ready

Fix Strategy:
- Use setTimeout with small delay (50-100ms)
- Implement retry mechanism (3-5 attempts)
- Add MutationObserver on tbody to detect row additions
- Use requestAnimationFrame + polling

------------------------------------------------------------------------

ISSUE #5: DOM Observer Won't Help
------------------------------------------------------------------------
Location: lines 94-108 (setupObserver)

Problem:
domObserver.onClass(
    'ListingPriceDisplay',
    'MarketplacePanel_myListingsTable',
    (tableNode) => {
        this.updateTable(tableNode);
    }
);

This observer triggers when table ELEMENT appears/disappears. It does NOT:
- Trigger when rows are added/removed
- Trigger when table content changes
- Trigger on mutations within the table

Why This Doesn't Help:
- Table element stays in DOM when listing is added
- Only tbody content changes (rows)
- Observer never fires during listing creation

Fix Strategy:
- Add separate MutationObserver for tbody changes
- Watch for childList mutations on tbody
- Trigger updateTable() when rows are added

------------------------------------------------------------------------

ISSUE #6: Timing of handleListing() vs clearDisplays()
------------------------------------------------------------------------
Location: lines 64-78 (updateHandler)

Problem:
for (const listing of data.endMarketListings) {
    this.handleListing(listing);  // Updates this.allListings
}
this.clearDisplays();  // Immediately removes columns

Flow:
1. Update internal state (this.allListings count changes)
2. Destroy UI (remove all columns)
3. Try to rebuild UI (but state/DOM mismatch)

This creates a window where:
- Internal state is correct (listingCount = 4)
- DOM state is old (rowCount = 3)
- Columns are removed
- Check fails, columns never restored

Fix Strategy:
- Don't clear displays until we're ready to re-add
- Clear and re-add in atomic operation
- Keep old columns until new ones are ready

------------------------------------------------------------------------

ISSUE #7: addDataToRows() Matching May Fail
------------------------------------------------------------------------
Location: lines 223-253 (addDataToRows)

Problem:
const matchedListing = listings.find(listing => {
    if (used.has(listing.id)) return false;

    return listing.itemHrid === rowInfo.itemHrid &&
           listing.enhancementLevel === rowInfo.enhancementLevel &&
           listing.isSell === rowInfo.isSell &&
           (!rowInfo.price || Math.abs(listing.price - rowInfo.price) < 0.01);
});

This matching relies on:
- Exact itemHrid match
- Exact enhancement level
- Exact isSell match
- Price tolerance of 0.01

If extractRowInfo() fails to parse the new row correctly:
- Match fails
- No listingId in dataset
- createPriceDisplays skips that row (line 337 check)

Why This Might Fail:
- New row might not be fully rendered when processed
- React might render placeholder content initially
- Price formatting might differ for new listing

Fix Strategy:
- Add logging to detect match failures
- Relax matching criteria or add ID-based fallback
- Verify extractRowInfo() works on fresh rows

------------------------------------------------------------------------

ISSUE #8: getBatch Pre-fetching Assumes Stable Count
------------------------------------------------------------------------
Location: lines 163-168 (updateTable)

Problem:
const itemsToPrice = Object.values(this.allListings).map(listing => ({
    itemHrid: listing.itemHrid,
    enhancementLevel: listing.enhancementLevel
}));
const priceCache = marketAPI.getPricesBatch(itemsToPrice);

This pre-fetches prices for ALL listings in this.allListings. If:
- this.allListings has 4 items (new listing added)
- DOM only has 3 rows (React not updated yet)
- rowCount check fails: 3 !== 4
- Function returns early
- Pre-fetched prices wasted

Not a bug, but inefficient. Consider:
- Move getBatch call after row count check passes
- Or cache results for next successful call

------------------------------------------------------------------------

ISSUE #9: Multiple Tabs Open Scenario
------------------------------------------------------------------------

Problem:
If user has multiple character tabs or browser tabs open:
- clearDisplays() is GLOBAL (removes from all tables)
- updateTable() only processes ONE table (visibleTable)
- Other tables lose columns and never get them back

This might not be the current issue but is a latent bug.

Fix Strategy:
- Make clearDisplays() table-specific
- Process all visible tables, not just one
- Add tab/character context awareness

================================================================================
ROOT CAUSE SUMMARY
================================================================================

Primary Root Cause:
  Race condition between WebSocket event and React DOM updates. The WebSocket
  event fires and updates internal state (this.allListings) before React has
  finished updating the DOM with the new row. The immediate call to
  updateTable() finds a mismatch between listingCount (already updated) and
  rowCount (not yet updated), causing it to abort before re-adding columns.

Contributing Factors:
  1. Strict row count equality check with no retry mechanism
  2. Aggressive clearDisplays() that removes columns globally
  3. No delay or polling to wait for React
  4. DOM observer doesn't trigger on row mutations
  5. No MutationObserver to detect when React adds the row

Why Page Refresh Works:
  On page refresh, the entire flow is synchronous and sequential:
  - Data loads from dataManager
  - React fully renders table
  - DOM observer fires AFTER table is complete
  - updateTable() sees matching counts
  - Columns added successfully

Why Manual Trigger Failed:
  The manual updateTable(visibleTable) call happens immediately in the same
  event loop tick as clearDisplays(), before React's next render cycle. The
  DOM hasn't updated yet, so the row count check fails.

================================================================================
PROPOSED SOLUTION STRATEGIES
================================================================================

STRATEGY A: Retry with Exponential Backoff (RECOMMENDED)
----------------------------------------------------------
Pros:
- Simple to implement
- Works around React timing without needing to understand it
- Gracefully handles variable delays

Cons:
- Adds slight delay before columns reappear
- Polling approach (not ideal but practical)

Implementation:
1. After clearDisplays(), schedule updateTable() with setTimeout
2. If rowCount check fails, retry after delay (50ms, 100ms, 200ms)
3. Max 5 retries before giving up
4. Log error if all retries fail

Code Outline:
updateTableWithRetry(tableNode, attempt = 0) {
    const tbody = tableNode.querySelector('tbody');
    if (!tbody) return;

    const rowCount = tbody.querySelectorAll('tr').length;
    const listingCount = Object.keys(this.allListings).length;

    if (rowCount !== listingCount && attempt < 5) {
        // Not ready yet, retry
        const delay = Math.min(50 * Math.pow(2, attempt), 500);
        setTimeout(() => this.updateTableWithRetry(tableNode, attempt + 1), delay);
        return;
    }

    // Proceed with normal updateTable logic...
}

------------------------------------------------------------------------

STRATEGY B: MutationObserver on tbody (MOST ROBUST)
----------------------------------------------------------
Pros:
- Event-driven (no polling)
- Reacts immediately when React adds row
- Most "correct" approach

Cons:
- More complex implementation
- Need to manage observer lifecycle
- May trigger multiple times

Implementation:
1. After clearDisplays(), attach MutationObserver to tbody
2. Watch for childList mutations (row additions)
3. When row count matches listing count, process table
4. Disconnect observer after processing

Code Outline:
setupTableMutationObserver(tableNode) {
    const tbody = tableNode.querySelector('tbody');
    if (!tbody) return;

    const observer = new MutationObserver(() => {
        const rowCount = tbody.querySelectorAll('tr').length;
        const listingCount = Object.keys(this.allListings).length;

        if (rowCount === listingCount) {
            observer.disconnect();
            this.updateTable(tableNode);
        }
    });

    observer.observe(tbody, { childList: true });
}

------------------------------------------------------------------------

STRATEGY C: Relax Row Count Check
----------------------------------------------------------
Pros:
- Simplest fix
- Allows partial processing

Cons:
- May process table before all rows present
- Could lead to incomplete data or mismatches

Implementation:
Change: if (rowCount !== listingCount)
To:     if (rowCount < listingCount - 1)  // Allow off-by-one

Or remove check entirely and process available rows.

Risk: May process too early during initial load.

------------------------------------------------------------------------

STRATEGY D: Debounced Processing
----------------------------------------------------------
Pros:
- Handles multiple rapid updates gracefully
- Reduces unnecessary re-renders

Cons:
- Adds complexity
- Still needs delay mechanism

Implementation:
1. Debounce updateTable() calls
2. Wait for "quiet period" before processing
3. Combine with retry or MutationObserver

------------------------------------------------------------------------

STRATEGY E: Don't Clear, Overlay Instead
----------------------------------------------------------
Pros:
- Never lose columns
- Update in place instead of remove/re-add

Cons:
- More complex update logic
- Need to handle row additions/removals carefully

Implementation:
1. Don't call clearDisplays()
2. Update existing cells in place
3. Add cells only for new rows
4. Remove cells only for removed rows

This is a larger refactor but most robust long-term solution.

================================================================================
RECOMMENDED SOLUTION
================================================================================

Immediate Fix (Strategy A - Retry with Backoff):
  Simple, effective, low-risk. Adds minimal delay (50-200ms typically) which
  is acceptable for this use case. Works around React timing without needing
  to understand React's internals.

Long-term Fix (Strategy B - MutationObserver):
  More robust, event-driven, no polling. Should be implemented after immediate
  fix is confirmed working. Can replace retry logic with observer pattern.

Additional Improvements:
  1. Make clearDisplays() table-specific instead of global
  2. Add error logging for failed matches in addDataToRows()
  3. Consider Strategy E (overlay instead of clear) for future refactor

================================================================================
TESTING REQUIREMENTS
================================================================================

After fix is implemented, test:
1. Create new sell listing - columns should persist
2. Create new buy listing - columns should persist
3. Cancel existing listing - columns should update correctly
4. Listing partially fills - columns should update correctly
5. Create multiple listings rapidly - no race conditions
6. Switch between items in My Listings - columns correct
7. Multiple browser tabs - no cross-contamination

Performance test:
- Time from listing creation to columns reappearing
- Target: <200ms delay acceptable
- Measure retry attempts needed (should be 1-2 typically)

================================================================================
END OF ANALYSIS
================================================================================
